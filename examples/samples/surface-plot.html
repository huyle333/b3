<!DOCTYPE html>

<html lang="en">
	<head>
		<title>b3.js - example</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link href='css/style.css' rel='stylesheet' type='text/css'>
	</head>

	<body>
		<div id="container"></div>
		<div id="cursor"></div>
	</body>

	<script type="text/javascript" src="js/Detector.js"></script>
	<script type="text/javascript" src="js/jquery.min.js"></script>
	<!--
	three.js 3d library
	-->
	<script type="text/javascript" src="js/three.min.js"></script>
	<script type="text/javascript" src="js/leap.min.js"></script>
	<script type="text/javascript" src="js/LeapCameraControls.js"></script>
	<script type="text/javascript" src="js/LeapObjectControls.js"></script>

	<!--
	VRControls.js acquires positional information from connected VR devices and applies the transformations to a three.js camera object.
	 -->
	<script src="js/VRControls.js"></script>

	<!--
	VREffect.js handles stereo camera setup and rendering.
	-->
	<script src="js/VREffect.js"></script>

	<script>
		var objects = [], objectsControls = [];
		var cameraControls;
		var coords1, coords2, coords3;
		var lastControlsIndex = -1, controlsIndex = -1, index = -1;

		/*
		Setup three.js WebGL renderer
		*/
		var renderer = new THREE.WebGLRenderer( { antialias: true } );
		renderer.setSize($(window).width(), $(window).height());
		renderer.setClearColor(0xffffff, 1);

		/*
		Append the canvas element created by the renderer to document body element.
		*/
		document.body.appendChild( renderer.domElement );

		/*
		Create a three.js scene
		*/
		var scene = new THREE.Scene();

		/*
		Create a three.js camera
		*/
		var camera = new THREE.PerspectiveCamera( 25, window.innerWidth / window.innerHeight, 0.1, 10000 );
		camera.position.x = 200;
        camera.position.y = 200;
        camera.position.z = 200;
       	
		var origin = new THREE.Vector3(-11, 0, -11);
		camera.lookAt(origin);
		

        // world coordinate system (thin dashed helping lines)
        var lineGeometry = new THREE.Geometry();
        var vertArray = lineGeometry.vertices;
        vertArray.push(new THREE.Vector3(150, 0, 0), origin, new THREE.Vector3(0, 150, 0), origin, new THREE.Vector3(0, 0, 150));
        lineGeometry.computeLineDistances();
        var lineMaterial = new THREE.LineDashedMaterial({color: 0x000000, dashSize: 1, gapSize: 2});
        var coords = new THREE.Line(lineGeometry, lineMaterial);
        scene.add(coords);

		/*
		Apply VR headset orientation and positional to camera.
		*/
		var controls = new THREE.VRControls( camera );

		cameraControls = new THREE.LeapCameraControls(camera);

        cameraControls.rotateEnabled  = true;
        cameraControls.rotateSpeed    = 3;
        cameraControls.rotateHands    = 1;
        cameraControls.rotateFingers  = [2, 3];
        
        cameraControls.zoomEnabled    = true;
        cameraControls.zoomSpeed      = 6;
        cameraControls.zoomHands      = 1;
        cameraControls.zoomFingers    = [4, 5];
        cameraControls.zoomMin        = 50;
        cameraControls.zoomMax        = 2000;
        
        cameraControls.panEnabled     = true;
        cameraControls.panSpeed       = 2;
        cameraControls.panHands       = 2;
        cameraControls.panFingers     = [6, 12];
        cameraControls.panRightHanded = false; // for left-handed person

		/*
		Apply VR stereo rendering to renderer
		*/
		var effect = new THREE.VREffect( renderer );
		effect.setSize( window.innerWidth, window.innerHeight );

        initGraph();

      function initGraph(){
    data = initData();
    var geometry = new THREE.Geometry();
    var colors = [];

    var width = data.length, height = data[0].length;
    data.forEach(function(col){
  col.forEach(function(val){
      geometry.vertices.push(new THREE.Vector3(val.x,val.y,val.z))
      colors.push(getColor(2.5,0,val.z));
  });
    });

    var offset = function(x,y){
  return x*width+y;
    }
    
    for(var x=0;x<width-1;x++){
  for(var y=0;y<height-1;y++){
      var vec0 = new THREE.Vector3(), vec1 = new THREE.Vector3(), n_vec = new THREE.Vector3();
      // one of two triangle polygons in one rectangle
      vec0.subVectors(geometry.vertices[offset(x,y)],geometry.vertices[offset(x+1,y)]);
      vec1.subVectors(geometry.vertices[offset(x,y)],geometry.vertices[offset(x,y+1)]); 
      n_vec.crossVectors(vec0,vec1).normalize();
      geometry.faces.push(new THREE.Face3(offset(x,y),offset(x+1,y),offset(x,y+1), n_vec, [colors[offset(x,y)],colors[offset(x+1,y)],colors[offset(x,y+1)]]));
      geometry.faces.push(new THREE.Face3(offset(x,y),offset(x,y+1),offset(x+1,y), n_vec.negate(), [colors[offset(x,y)],colors[offset(x,y+1)],colors[offset(x+1,y)]]));
      // the other one
      vec0.subVectors(geometry.vertices[offset(x+1,y)],geometry.vertices[offset(x+1,y+1)]);
      vec1.subVectors(geometry.vertices[offset(x,y+1)],geometry.vertices[offset(x+1,y+1)]); 
      n_vec.crossVectors(vec0,vec1).normalize();
      geometry.faces.push(new THREE.Face3(offset(x+1,y),offset(x+1,y+1),offset(x,y+1), n_vec, [colors[offset(x+1,y)],colors[offset(x+1,y+1)],colors[offset(x,y+1)]]));
      geometry.faces.push(new THREE.Face3(offset(x+1,y),offset(x,y+1),offset(x+1,y+1), n_vec.negate(), [colors[offset(x+1,y)],colors[offset(x,y+1)],colors[offset(x+1,y+1)]]));
  }
    }

    var material = new THREE.MeshLambertMaterial({ vertexColors: THREE.VertexColors});
    var mesh = new THREE.Mesh(geometry, material);
    scene.add(mesh);
}

function initData(){
    var BIGIN=-10, END=10;
    var data = new Array();
    for(var x=BIGIN;x<END;x++){
  var row = [];
  for(var y=BIGIN;y<END;y++){
      z = 2.5*(Math.cos(Math.sqrt(x*x+y*y))+1);
      row.push({x: y, y: z, z: x});
  }
  data.push(row);
    }
    return data;
}

function getColor(max,min,val){
    var MIN_L=40,MAX_L=100;
    var color = new THREE.Color();
    var h = 0/240;
    var s = 80/240;
    var l = (((MAX_L-MIN_L)/(max-min))*val)/240;
    color.setHSL(h,s,l);
    return color;
}

		/*
		Request animation frame loop function
		*/
		function animate() {
			/*
			Apply rotation to cube mesh
			*/
			// cube.rotation.y += 0.01;

			/*
			Update VR headset position and apply to camera.
			*/
			controls.update();

			/*
			Render the scene through the VREffect.
			*/
			effect.render( scene, camera );

			requestAnimationFrame( animate );
		}

		/*
		Kick off animation loop
		*/
		animate();

		// leap loop
        Leap.loop(function(frame) {
          // show cursor
          showCursor(frame);

          // set correct camera control
          controlsIndex = focusObject(frame);
          if (index == -1) {
            cameraControls.update(frame);
          } else {
            objectsControls[index].update(frame);
          };

          effect.render(scene, camera);
        });

        // detect controls change
        setInterval(changeControlsIndex, 250);

        function changeControlsIndex() {
        if (lastControlsIndex == controlsIndex) {
          if (index != controlsIndex && controlsIndex > -2) {
            // new object or camera to control
            if (controlsIndex > -2) {
              if (index > -1) objects[index].material.color.setHex(0xefefef);
              index = controlsIndex;
              if (index > -1) objects[index].material.color.setHex(0xff0000);
            }
          };
        }; 
        lastControlsIndex = controlsIndex;
      };

      function transform(tipPosition, w, h) {
        var width = 150;
        var height = 150;
        var minHeight = 100;

        var ftx = tipPosition[0];
        var fty = tipPosition[1];
        ftx = (ftx > width ? width - 1 : (ftx < -width ? -width + 1 : ftx));
        fty = (fty > 2*height ? 2*height - 1 : (fty < minHeight ? minHeight + 1 : fty));
        var x = THREE.Math.mapLinear(ftx, -width, width, 0, w);
        var y = THREE.Math.mapLinear(fty, 2*height, minHeight, 0, h);
        return [x, y];
      };

      function showCursor(frame) {
        var hl = frame.hands.length;
        var fl = frame.pointables.length;

        if (hl == 1 && fl == 1) {
          var f = frame.pointables[0];
          var cont = $(renderer.domElement);
          var offset = cont.offset();
          var coords = transform(f.tipPosition, cont.width(), cont.height());
          $("#cursor").css('left', offset.left + coords[0] - (($("#cursor").width() - 1)/2 + 1));
          $("#cursor").css('top', offset.top + coords[1] - (($("#cursor").height() - 1)/2 + 1));
        } else {
          $("#cursor").css('left', -1000);
          $("#cursor").css('top', -1000);
        };
      };

      function focusObject(frame) {
        var hl = frame.hands.length;
        var fl = frame.pointables.length;

        if (hl == 1 && fl == 1) {
          var f = frame.pointables[0];
          var cont = $(renderer.domElement);
          var coords = transform(f.tipPosition, cont.width(), cont.height());
          var vpx = (coords[0]/cont.width())*2 - 1;
          var vpy = -(coords[1]/cont.height())*2 + 1;
          var vector = new THREE.Vector3(vpx, vpy, 0.5);
          // projector.unprojectVector(vector, camera);
          var raycaster = new THREE.Raycaster(camera.position, vector.sub(camera.position).normalize());
          var intersects = raycaster.intersectObjects(objects);
          if (intersects.length > 0) { 
            var i = 0;
            while(!intersects[i].object.visible) i++;
            var intersected = intersects[i];
            return objects.indexOf(intersected.object);
          } else {
            return -1;
          };
        };

        return -2;
      };

        function render() {
        	effect.render(scene, camera);
      	};

		/*
		Listen for double click event to enter full-screen VR mode
		*/
		document.body.addEventListener( 'dblclick', function() {
			effect.setFullScreen( true );
		});

		/*
		Listen for keyboard event and zero positional sensor on appropriate keypress.
		*/
		function onkey(event) {
	    event.preventDefault();

	    if (event.keyCode == 90) { // z
	    	controls.zeroSensor();
	    }
	  };

	  window.addEventListener("keydown", onkey, true);


		/*
		Handle window resizes
		*/
		function onWindowResize() {
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			effect.setSize( window.innerWidth, window.innerHeight );
		}

		window.addEventListener( 'resize', onWindowResize, false );

	</script>
</html>
